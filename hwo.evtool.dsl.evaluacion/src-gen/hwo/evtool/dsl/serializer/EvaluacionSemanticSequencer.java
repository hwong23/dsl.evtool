/*
 * generated by Xtext 2.25.0
 */
package hwo.evtool.dsl.serializer;

import com.google.inject.Inject;
import hwo.evtool.dsl.evaluacion.Comando;
import hwo.evtool.dsl.evaluacion.Estado;
import hwo.evtool.dsl.evaluacion.EvaluacionPackage;
import hwo.evtool.dsl.evaluacion.Evento;
import hwo.evtool.dsl.evaluacion.IntConstant;
import hwo.evtool.dsl.evaluacion.MaquinaEstados;
import hwo.evtool.dsl.evaluacion.SiNoConstant;
import hwo.evtool.dsl.evaluacion.StringConstant;
import hwo.evtool.dsl.evaluacion.Transicion;
import hwo.evtool.dsl.services.EvaluacionGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EvaluacionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EvaluacionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EvaluacionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EvaluacionPackage.COMANDO:
				sequence_Comando(context, (Comando) semanticObject); 
				return; 
			case EvaluacionPackage.ESTADO:
				sequence_Estado(context, (Estado) semanticObject); 
				return; 
			case EvaluacionPackage.EVENTO:
				sequence_Evento(context, (Evento) semanticObject); 
				return; 
			case EvaluacionPackage.INT_CONSTANT:
				sequence_Atomo(context, (IntConstant) semanticObject); 
				return; 
			case EvaluacionPackage.MAQUINA_ESTADOS:
				sequence_MaquinaEstados(context, (MaquinaEstados) semanticObject); 
				return; 
			case EvaluacionPackage.SI_NO_CONSTANT:
				sequence_Atomo(context, (SiNoConstant) semanticObject); 
				return; 
			case EvaluacionPackage.STRING_CONSTANT:
				sequence_Atomo(context, (StringConstant) semanticObject); 
				return; 
			case EvaluacionPackage.TRANSICION:
				sequence_Transicion(context, (Transicion) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Atomo returns IntConstant
	 *
	 * Constraint:
	 *     valor=Puntuacion
	 */
	protected void sequence_Atomo(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.ATOMO__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.ATOMO__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomoAccess().getValorPuntuacionParserRuleCall_0_1_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomo returns SiNoConstant
	 *
	 * Constraint:
	 *     (valor='S' | valor='N')
	 */
	protected void sequence_Atomo(ISerializationContext context, SiNoConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atomo returns StringConstant
	 *
	 * Constraint:
	 *     valor=STRING
	 */
	protected void sequence_Atomo(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.ATOMO__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.ATOMO__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomoAccess().getValorSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comando returns Comando
	 *
	 * Constraint:
	 *     (name=ID argumento=Atomo comentario=STRING?)
	 */
	protected void sequence_Comando(ISerializationContext context, Comando semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Estado returns Estado
	 *
	 * Constraint:
	 *     (name=ID actions+=[Comando|ID]* transitions+=Transicion*)
	 */
	protected void sequence_Estado(ISerializationContext context, Estado semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evento returns Evento
	 *
	 * Constraint:
	 *     (name=ID code=ID)
	 */
	protected void sequence_Evento(ISerializationContext context, Evento semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.EVENTO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.EVENTO__NAME));
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.EVENTO__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.EVENTO__CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventoAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEventoAccess().getCodeIDTerminalRuleCall_1_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MaquinaEstados returns MaquinaEstados
	 *
	 * Constraint:
	 *     (events+=Evento* resetEvents+=[Evento|ID]* commands+=Comando* states+=Estado*)
	 */
	protected void sequence_MaquinaEstados(ISerializationContext context, MaquinaEstados semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transicion returns Transicion
	 *
	 * Constraint:
	 *     (event=[Evento|ID] state=[Estado|ID])
	 */
	protected void sequence_Transicion(ISerializationContext context, Transicion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.TRANSICION__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.TRANSICION__EVENT));
			if (transientValues.isValueTransient(semanticObject, EvaluacionPackage.Literals.TRANSICION__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EvaluacionPackage.Literals.TRANSICION__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransicionAccess().getEventEventoIDTerminalRuleCall_0_0_1(), semanticObject.eGet(EvaluacionPackage.Literals.TRANSICION__EVENT, false));
		feeder.accept(grammarAccess.getTransicionAccess().getStateEstadoIDTerminalRuleCall_2_0_1(), semanticObject.eGet(EvaluacionPackage.Literals.TRANSICION__STATE, false));
		feeder.finish();
	}
	
	
}
